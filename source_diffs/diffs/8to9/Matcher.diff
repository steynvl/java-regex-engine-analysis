--- /dev/fd/63	2021-02-14 05:30:30.119807804 +0200
+++ /dev/fd/62	2021-02-14 05:30:30.119807804 +0200
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2015, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -23,7 +23,16 @@
  * questions.
  */
 package za.ac.sun.cs.regex;
+import java.util.ConcurrentModificationException;
+import java.util.Iterator;
+import java.util.NoSuchElementException;
 import java.util.Objects;
+import java.util.Spliterator;
+import java.util.Spliterators;
+import java.util.function.Consumer;
+import java.util.function.Function;
+import java.util.stream.Stream;
+import java.util.stream.StreamSupport;
 /**
  * An engine that performs match operations on a {@linkplain java.lang.CharSequence
  * character sequence} by interpreting a {@link Pattern}.
@@ -51,7 +60,7 @@
  *
  * <p> A matcher finds matches in a subset of its input called the
  * <i>region</i>. By default, the region contains all of the matcher's input.
- * The region can be modified via the{@link #region region} method and queried
+ * The region can be modified via the {@link #region region} method and queried
  * via the {@link #regionStart regionStart} and {@link #regionEnd regionEnd}
  * methods. The way that the region boundaries interact with some pattern
  * constructs can be changed. See {@link #useAnchoringBounds
@@ -62,9 +71,10 @@
  * new strings whose contents can, if desired, be computed from the match
  * result.  The {@link #appendReplacement appendReplacement} and {@link
  * #appendTail appendTail} methods can be used in tandem in order to collect
- * the result into an existing string buffer, or the more convenient {@link
- * #replaceAll replaceAll} method can be used to create a string in which every
- * matching subsequence in the input sequence is replaced.
+ * the result into an existing string buffer or string builder. Alternatively,
+ * the more convenient {@link #replaceAll replaceAll} method can be used to
+ * create a string in which every matching subsequence in the input sequence
+ * is replaced.
  *
  * <p> The explicit state of a matcher includes the start and end indices of
  * the most recent successful match.  It also includes the start and end
@@ -153,6 +163,13 @@
      */
     int[] locals;
     /**
+     * Storage used by top greedy Loop node to store a specific hash set to
+     * keep the beginning index of the failed repetition match. The nodes
+     * themselves are stateless, so they rely on this field to hold state
+     * during a match.
+     */
+    IntHashSet[] localsPos;
+    /**
      * Boolean indicating whether or not more input could change
      * the results of the last match.
      *
@@ -189,6 +206,10 @@
      */
     boolean anchoringBounds = true;
     /**
+     * Number of times this matcher's state has been modified
+     */
+    int modCount;
+    /**
      * No default constructor.
      */
     Matcher() {
@@ -203,6 +224,7 @@
         int parentGroupCount = Math.max(parent.capturingGroupCount, 10);
         groups = new int[parentGroupCount * 2];
         locals = new int[parent.localCount];
+        localsPos = new IntHashSet[parent.localTCNCount];
         // Put fields into initial states
         reset();
     }
@@ -219,18 +241,83 @@
      * The result is unaffected by subsequent operations performed upon this
      * matcher.
      *
-     * @return  a <code>MatchResult</code> with the state of this matcher
+     * @return  a {@code MatchResult} with the state of this matcher
      * @since 1.5
      */
     public MatchResult toMatchResult() {
-        Matcher result = new Matcher(this.parentPattern, text.toString());
-        result.first = this.first;
-        result.last = this.last;
-        result.groups = this.groups.clone();
-        return result;
+        return toMatchResult(text.toString());
+    }
+    private MatchResult toMatchResult(String text) {
+        return new ImmutableMatchResult(this.first,
+                                        this.last,
+                                        groupCount(),
+                                        this.groups.clone(),
+                                        text);
+    }
+    private static class ImmutableMatchResult implements MatchResult {
+        private final int first;
+        private final int last;
+        private final int[] groups;
+        private final int groupCount;
+        private final String text;
+        ImmutableMatchResult(int first, int last, int groupCount,
+                             int groups[], String text)
+        {
+            this.first = first;
+            this.last = last;
+            this.groupCount = groupCount;
+            this.groups = groups;
+            this.text = text;
+        }
+        @Override
+        public int start() {
+            checkMatch();
+            return first;
+        }
+        @Override
+        public int start(int group) {
+            checkMatch();
+            if (group < 0 || group > groupCount)
+                throw new IndexOutOfBoundsException("No group " + group);
+            return groups[group * 2];
+        }
+        @Override
+        public int end() {
+            checkMatch();
+            return last;
+        }
+        @Override
+        public int end(int group) {
+            checkMatch();
+            if (group < 0 || group > groupCount)
+                throw new IndexOutOfBoundsException("No group " + group);
+            return groups[group * 2 + 1];
+        }
+        @Override
+        public int groupCount() {
+            return groupCount;
+        }
+        @Override
+        public String group() {
+            checkMatch();
+            return group(0);
+        }
+        @Override
+        public String group(int group) {
+            checkMatch();
+            if (group < 0 || group > groupCount)
+                throw new IndexOutOfBoundsException("No group " + group);
+            if ((groups[group*2] == -1) || (groups[group*2+1] == -1))
+                return null;
+            return text.subSequence(groups[group * 2], groups[group * 2 + 1]).toString();
+        }
+        private void checkMatch() {
+            if (first < 0)
+                throw new IllegalStateException("No match found");
+        }
     }
     /**
-      * Changes the <tt>Pattern</tt> that this <tt>Matcher</tt> uses to
+      * Changes the {@code Pattern} that this {@code Matcher} uses to
       * find matches with.
       *
       * <p> This method causes this matcher to lose information
@@ -242,7 +329,7 @@
       *         The new pattern used by this matcher
       * @return  This matcher
       * @throws  IllegalArgumentException
-      *          If newPattern is <tt>null</tt>
+      *          If newPattern is {@code null}
       * @since 1.5
       */
     public Matcher usePattern(Pattern newPattern) {
@@ -257,6 +344,8 @@
             groups[i] = -1;
         for (int i = 0; i < locals.length; i++)
             locals[i] = -1;
+        localsPos = new IntHashSet[parentPattern.localTCNCount];
+        modCount++;
         return this;
     }
     /**
@@ -277,9 +366,14 @@
             groups[i] = -1;
         for(int i=0; i<locals.length; i++)
             locals[i] = -1;
+        for (int i = 0; i < localsPos.length; i++) {
+            if (localsPos[i] != null)
+                localsPos[i].clear();
+        }
         lastAppendPosition = 0;
         from = 0;
         to = getTextLength();
+        modCount++;
         return this;
     }
     /**
@@ -320,14 +414,14 @@
      *
      * <p> <a href="Pattern.html#cg">Capturing groups</a> are indexed from left
      * to right, starting at one.  Group zero denotes the entire pattern, so
-     * the expression <i>m.</i><tt>start(0)</tt> is equivalent to
-     * <i>m.</i><tt>start()</tt>.  </p>
+     * the expression <i>m.</i>{@code start(0)} is equivalent to
+     * <i>m.</i>{@code start()}.  </p>
      *
      * @param  group
      *         The index of a capturing group in this matcher's pattern
      *
      * @return  The index of the first character captured by the group,
-     *          or <tt>-1</tt> if the match was successful but the group
+     *          or {@code -1} if the match was successful but the group
      *          itself did not match anything
      *
      * @throws  IllegalStateException
@@ -389,14 +483,14 @@
      *
      * <p> <a href="Pattern.html#cg">Capturing groups</a> are indexed from left
      * to right, starting at one.  Group zero denotes the entire pattern, so
-     * the expression <i>m.</i><tt>end(0)</tt> is equivalent to
-     * <i>m.</i><tt>end()</tt>.  </p>
+     * the expression <i>m.</i>{@code end(0)} is equivalent to
+     * <i>m.</i>{@code end()}.  </p>
      *
      * @param  group
      *         The index of a capturing group in this matcher's pattern
      *
      * @return  The offset after the last character captured by the group,
-     *          or <tt>-1</tt> if the match was successful
+     *          or {@code -1} if the match was successful
      *          but the group itself did not match anything
      *
      * @throws  IllegalStateException
@@ -442,11 +536,11 @@
      * Returns the input subsequence matched by the previous match.
      *
      * <p> For a matcher <i>m</i> with input sequence <i>s</i>,
-     * the expressions <i>m.</i><tt>group()</tt> and
-     * <i>s.</i><tt>substring(</tt><i>m.</i><tt>start(),</tt>&nbsp;<i>m.</i><tt>end())</tt>
+     * the expressions <i>m.</i>{@code group()} and
+     * <i>s.</i>{@code substring(}<i>m.</i>{@code start(),}&nbsp;<i>m.</i>{@code end())}
      * are equivalent.  </p>
      *
-     * <p> Note that some patterns, for example <tt>a*</tt>, match the empty
+     * <p> Note that some patterns, for example {@code a*}, match the empty
      * string.  This method will return the empty string when the pattern
      * successfully matches the empty string in the input.  </p>
      *
@@ -465,18 +559,19 @@
      * previous match operation.
      *
      * <p> For a matcher <i>m</i>, input sequence <i>s</i>, and group index
-     * <i>g</i>, the expressions <i>m.</i><tt>group(</tt><i>g</i><tt>)</tt> and
-     * <i>s.</i><tt>substring(</tt><i>m.</i><tt>start(</tt><i>g</i><tt>),</tt>&nbsp;<i>m.</i><tt>end(</tt><i>g</i><tt>))</tt>
+     * <i>g</i>, the expressions <i>m.</i>{@code group(}<i>g</i>{@code )} and
+     * <i>s.</i>{@code substring(}<i>m.</i>{@code start(}<i>g</i>{@code
+     * ),}&nbsp;<i>m.</i>{@code end(}<i>g</i>{@code ))}
      * are equivalent.  </p>
      *
      * <p> <a href="Pattern.html#cg">Capturing groups</a> are indexed from left
      * to right, starting at one.  Group zero denotes the entire pattern, so
-     * the expression <tt>m.group(0)</tt> is equivalent to <tt>m.group()</tt>.
+     * the expression {@code m.group(0)} is equivalent to {@code m.group()}.
      * </p>
      *
      * <p> If the match was successful but the group specified failed to match
-     * any part of the input sequence, then <tt>null</tt> is returned. Note
-     * that some groups, for example <tt>(a*)</tt>, match the empty string.
+     * any part of the input sequence, then {@code null} is returned. Note
+     * that some groups, for example {@code (a*)}, match the empty string.
      * This method will return the empty string when such a group successfully
      * matches the empty string in the input.  </p>
      *
@@ -484,7 +579,7 @@
      *         The index of a capturing group in this matcher's pattern
      *
      * @return  The (possibly empty) subsequence captured by the group
-     *          during the previous match, or <tt>null</tt> if the group
+     *          during the previous match, or {@code null} if the group
      *          failed to match part of the input
      *
      * @throws  IllegalStateException
@@ -510,8 +605,8 @@
      * match operation.
      *
      * <p> If the match was successful but the group specified failed to match
-     * any part of the input sequence, then <tt>null</tt> is returned. Note
-     * that some groups, for example <tt>(a*)</tt>, match the empty string.
+     * any part of the input sequence, then {@code null} is returned. Note
+     * that some groups, for example {@code (a*)}, match the empty string.
      * This method will return the empty string when such a group successfully
      * matches the empty string in the input.  </p>
      *
@@ -519,7 +614,7 @@
      *         The name of a named-capturing group in this matcher's pattern
      *
      * @return  The (possibly empty) subsequence captured by the named group
-     *          during the previous match, or <tt>null</tt> if the group
+     *          during the previous match, or {@code null} if the group
      *          failed to match part of the input
      *
      * @throws  IllegalStateException
@@ -556,9 +651,9 @@
      * Attempts to match the entire region against the pattern.
      *
      * <p> If the match succeeds then more information can be obtained via the
-     * <tt>start</tt>, <tt>end</tt>, and <tt>group</tt> methods.  </p>
+     * {@code start}, {@code end}, and {@code group} methods.  </p>
      *
-     * @return  <tt>true</tt> if, and only if, the entire region sequence
+     * @return  {@code true} if, and only if, the entire region sequence
      *          matches this matcher's pattern
      */
     public boolean matches() {
@@ -574,9 +669,9 @@
      * match.
      *
      * <p> If the match succeeds then more information can be obtained via the
-     * <tt>start</tt>, <tt>end</tt>, and <tt>group</tt> methods.  </p>
+     * {@code start}, {@code end}, and {@code group} methods.  </p>
      *
-     * @return  <tt>true</tt> if, and only if, a subsequence of the input
+     * @return  {@code true} if, and only if, a subsequence of the input
      *          sequence matches this matcher's pattern
      */
     public boolean find() {
@@ -600,7 +695,7 @@
      * index.
      *
      * <p> If the match succeeds then more information can be obtained via the
-     * <tt>start</tt>, <tt>end</tt>, and <tt>group</tt> methods, and subsequent
+     * {@code start}, {@code end}, and {@code group} methods, and subsequent
      * invocations of the {@link #find()} method will start at the first
      * character not matched by this match.  </p>
      *
@@ -609,7 +704,7 @@
      *          If start is less than zero or if start is greater than the
      *          length of the input sequence.
      *
-     * @return  <tt>true</tt> if, and only if, a subsequence of the input
+     * @return  {@code true} if, and only if, a subsequence of the input
      *          sequence starting at the given index matches this matcher's
      *          pattern
      */
@@ -629,23 +724,23 @@
      * require that the entire region be matched.
      *
      * <p> If the match succeeds then more information can be obtained via the
-     * <tt>start</tt>, <tt>end</tt>, and <tt>group</tt> methods.  </p>
+     * {@code start}, {@code end}, and {@code group} methods.  </p>
      *
-     * @return  <tt>true</tt> if, and only if, a prefix of the input
+     * @return  {@code true} if, and only if, a prefix of the input
      *          sequence matches this matcher's pattern
      */
     public boolean lookingAt() {
         return match(from, NOANCHOR);
     }
     /**
-     * Returns a literal replacement <code>String</code> for the specified
-     * <code>String</code>.
+     * Returns a literal replacement {@code String} for the specified
+     * {@code String}.
      *
-     * This method produces a <code>String</code> that will work
-     * as a literal replacement <code>s</code> in the
-     * <code>appendReplacement</code> method of the {@link Matcher} class.
-     * The <code>String</code> produced will match the sequence of characters
-     * in <code>s</code> treated as a literal sequence. Slashes ('\') and
+     * This method produces a {@code String} that will work
+     * as a literal replacement {@code s} in the
+     * {@code appendReplacement} method of the {@link Matcher} class.
+     * The {@code String} produced will match the sequence of characters
+     * in {@code s} treated as a literal sequence. Slashes ('\') and
      * dollar signs ('$') will be given no special meaning.
      *
      * @param  s The string to be literalized
@@ -676,7 +771,7 @@
      *   append position, and appends them to the given string buffer.  It
      *   stops after reading the last character preceding the previous match,
      *   that is, the character at index {@link
-     *   #start()}&nbsp;<tt>-</tt>&nbsp;<tt>1</tt>.  </p></li>
+     *   #start()}&nbsp;{@code -}&nbsp;{@code 1}.  </p></li>
      *
      *   <li><p> It appends the given replacement string to the string buffer.
      *   </p></li>
@@ -689,21 +784,21 @@
      *
      * <p> The replacement string may contain references to subsequences
      * captured during the previous match: Each occurrence of
-     * <tt>${</tt><i>name</i><tt>}</tt> or <tt>$</tt><i>g</i>
+     * <code>${</code><i>name</i><code>}</code> or {@code $}<i>g</i>
      * will be replaced by the result of evaluating the corresponding
      * {@link #group(String) group(name)} or {@link #group(int) group(g)}
-     * respectively. For  <tt>$</tt><i>g</i>,
-     * the first number after the <tt>$</tt> is always treated as part of
+     * respectively. For {@code $}<i>g</i>,
+     * the first number after the {@code $} is always treated as part of
      * the group reference. Subsequent numbers are incorporated into g if
      * they would form a legal group reference. Only the numerals '0'
      * through '9' are considered as potential components of the group
-     * reference. If the second group matched the string <tt>"foo"</tt>, for
-     * example, then passing the replacement string <tt>"$2bar"</tt> would
-     * cause <tt>"foobar"</tt> to be appended to the string buffer. A dollar
-     * sign (<tt>$</tt>) may be included as a literal in the replacement
-     * string by preceding it with a backslash (<tt>\$</tt>).
+     * reference. If the second group matched the string {@code "foo"}, for
+     * example, then passing the replacement string {@code "$2bar"} would
+     * cause {@code "foobar"} to be appended to the string buffer. A dollar
+     * sign ({@code $}) may be included as a literal in the replacement
+     * string by preceding it with a backslash ({@code \$}).
      *
-     * <p> Note that backslashes (<tt>\</tt>) and dollar signs (<tt>$</tt>) in
+     * <p> Note that backslashes ({@code \}) and dollar signs ({@code $}) in
      * the replacement string may cause the results to be different than if it
      * were being treated as a literal replacement string. Dollar signs may be
      * treated as references to captured subsequences as described above, and
@@ -712,8 +807,8 @@
      *
      * <p> This method is intended to be used in a loop together with the
      * {@link #appendTail appendTail} and {@link #find find} methods.  The
-     * following code, for example, writes <tt>one dog two dogs in the
-     * yard</tt> to the standard-output stream: </p>
+     * following code, for example, writes {@code one dog two dogs in the
+     * yard} to the standard-output stream: </p>
      *
      * <blockquote><pre>
      * Pattern p = Pattern.compile("cat");
@@ -749,9 +844,112 @@
         // If no match, return error
         if (first < 0)
             throw new IllegalStateException("No match available");
-        // Process substitution string to replace group references with groups
-        int cursor = 0;
         StringBuilder result = new StringBuilder();
+        appendExpandedReplacement(replacement, result);
+        // Append the intervening text
+        sb.append(text, lastAppendPosition, first);
+        // Append the match substitution
+        sb.append(result);
+        lastAppendPosition = last;
+        modCount++;
+        return this;
+    }
+    /**
+     * Implements a non-terminal append-and-replace step.
+     *
+     * <p> This method performs the following actions: </p>
+     *
+     * <ol>
+     *
+     *   <li><p> It reads characters from the input sequence, starting at the
+     *   append position, and appends them to the given string builder.  It
+     *   stops after reading the last character preceding the previous match,
+     *   that is, the character at index {@link
+     *   #start()}&nbsp;{@code -}&nbsp;{@code 1}.  </p></li>
+     *
+     *   <li><p> It appends the given replacement string to the string builder.
+     *   </p></li>
+     *
+     *   <li><p> It sets the append position of this matcher to the index of
+     *   the last character matched, plus one, that is, to {@link #end()}.
+     *   </p></li>
+     *
+     * </ol>
+     *
+     * <p> The replacement string may contain references to subsequences
+     * captured during the previous match: Each occurrence of
+     * {@code $}<i>g</i> will be replaced by the result of
+     * evaluating {@link #group(int) group}{@code (}<i>g</i>{@code )}.
+     * The first number after the {@code $} is always treated as part of
+     * the group reference. Subsequent numbers are incorporated into g if
+     * they would form a legal group reference. Only the numerals '0'
+     * through '9' are considered as potential components of the group
+     * reference. If the second group matched the string {@code "foo"}, for
+     * example, then passing the replacement string {@code "$2bar"} would
+     * cause {@code "foobar"} to be appended to the string builder. A dollar
+     * sign ({@code $}) may be included as a literal in the replacement
+     * string by preceding it with a backslash ({@code \$}).
+     *
+     * <p> Note that backslashes ({@code \}) and dollar signs ({@code $}) in
+     * the replacement string may cause the results to be different than if it
+     * were being treated as a literal replacement string. Dollar signs may be
+     * treated as references to captured subsequences as described above, and
+     * backslashes are used to escape literal characters in the replacement
+     * string.
+     *
+     * <p> This method is intended to be used in a loop together with the
+     * {@link #appendTail appendTail} and {@link #find find} methods.  The
+     * following code, for example, writes {@code one dog two dogs in the
+     * yard} to the standard-output stream: </p>
+     *
+     * <blockquote><pre>
+     * Pattern p = Pattern.compile("cat");
+     * Matcher m = p.matcher("one cat two cats in the yard");
+     * StringBuilder sb = new StringBuilder();
+     * while (m.find()) {
+     *     m.appendReplacement(sb, "dog");
+     * }
+     * m.appendTail(sb);
+     * System.out.println(sb.toString());</pre></blockquote>
+     *
+     * @param  sb
+     *         The target string builder
+     * @param  replacement
+     *         The replacement string
+     * @return  This matcher
+     *
+     * @throws  IllegalStateException
+     *          If no match has yet been attempted,
+     *          or if the previous match operation failed
+     * @throws  IllegalArgumentException
+     *          If the replacement string refers to a named-capturing
+     *          group that does not exist in the pattern
+     * @throws  IndexOutOfBoundsException
+     *          If the replacement string refers to a capturing group
+     *          that does not exist in the pattern
+     * @since 9
+     */
+    public Matcher appendReplacement(StringBuilder sb, String replacement) {
+        // If no match, return error
+        if (first < 0)
+            throw new IllegalStateException("No match available");
+        StringBuilder result = new StringBuilder();
+        appendExpandedReplacement(replacement, result);
+        // Append the intervening text
+        sb.append(text, lastAppendPosition, first);
+        // Append the match substitution
+        sb.append(result);
+        lastAppendPosition = last;
+        modCount++;
+        return this;
+    }
+    /**
+     * Processes replacement string to replace group references with
+     * groups.
+     */
+    private StringBuilder appendExpandedReplacement(
+        String replacement, StringBuilder result) {
+        int cursor = 0;
         while (cursor < replacement.length()) {
             char nextChar = replacement.charAt(cursor);
             if (nextChar == '\\') {
@@ -803,8 +1001,8 @@
                     cursor++;
                 } else {
                     // The first number is always a group
-                    refNum = (int)nextChar - '0';
-                    if ((refNum < 0)||(refNum > 9))
+                    refNum = nextChar - '0';
+                    if ((refNum < 0) || (refNum > 9))
                         throw new IllegalArgumentException(
                             "Illegal group reference");
                     cursor++;
@@ -815,7 +1013,7 @@
                             break;
                         }
                         int nextDigit = replacement.charAt(cursor) - '0';
-                        if ((nextDigit < 0)||(nextDigit > 9)) { // not a number
+                        if ((nextDigit < 0) || (nextDigit > 9)) { // not a number
                             break;
                         }
                         int newRefNum = (refNum * 10) + nextDigit;
@@ -835,12 +1033,7 @@
                 cursor++;
             }
         }
-        // Append the intervening text
-        sb.append(text, lastAppendPosition, first);
-        // Append the match substitution
-        sb.append(result);
-        lastAppendPosition = last;
-        return this;
+        return result;
     }
     /**
      * Implements a terminal append-and-replace step.
@@ -861,6 +1054,26 @@
         return sb;
     }
     /**
+     * Implements a terminal append-and-replace step.
+     *
+     * <p> This method reads characters from the input sequence, starting at
+     * the append position, and appends them to the given string builder.  It is
+     * intended to be invoked after one or more invocations of the {@link
+     * #appendReplacement appendReplacement} method in order to copy the
+     * remainder of the input sequence.  </p>
+     *
+     * @param  sb
+     *         The target string builder
+     *
+     * @return  The target string builder
+     *
+     * @since 9
+     */
+    public StringBuilder appendTail(StringBuilder sb) {
+        sb.append(text, lastAppendPosition, getTextLength());
+        return sb;
+    }
+    /**
      * Replaces every subsequence of the input sequence that matches the
      * pattern with the given replacement string.
      *
@@ -871,17 +1084,17 @@
      * string may contain references to captured subsequences as in the {@link
      * #appendReplacement appendReplacement} method.
      *
-     * <p> Note that backslashes (<tt>\</tt>) and dollar signs (<tt>$</tt>) in
+     * <p> Note that backslashes ({@code \}) and dollar signs ({@code $}) in
      * the replacement string may cause the results to be different than if it
      * were being treated as a literal replacement string. Dollar signs may be
      * treated as references to captured subsequences as described above, and
      * backslashes are used to escape literal characters in the replacement
      * string.
      *
-     * <p> Given the regular expression <tt>a*b</tt>, the input
-     * <tt>"aabfooaabfooabfoob"</tt>, and the replacement string
-     * <tt>"-"</tt>, an invocation of this method on a matcher for that
-     * expression would yield the string <tt>"-foo-foo-foo-"</tt>.
+     * <p> Given the regular expression {@code a*b}, the input
+     * {@code "aabfooaabfooabfoob"}, and the replacement string
+     * {@code "-"}, an invocation of this method on a matcher for that
+     * expression would yield the string {@code "-foo-foo-foo-"}.
      *
      * <p> Invoking this method changes this matcher's state.  If the matcher
      * is to be used in further matching operations then it should first be
@@ -898,7 +1111,7 @@
         reset();
         boolean result = find();
         if (result) {
-            StringBuffer sb = new StringBuffer();
+            StringBuilder sb = new StringBuilder();
             do {
                 appendReplacement(sb, replacement);
                 result = find();
@@ -909,6 +1122,169 @@
         return text.toString();
     }
     /**
+     * Replaces every subsequence of the input sequence that matches the
+     * pattern with the result of applying the given replacer function to the
+     * match result of this matcher corresponding to that subsequence.
+     * Exceptions thrown by the function are relayed to the caller.
+     *
+     * <p> This method first resets this matcher.  It then scans the input
+     * sequence looking for matches of the pattern.  Characters that are not
+     * part of any match are appended directly to the result string; each match
+     * is replaced in the result by the applying the replacer function that
+     * returns a replacement string.  Each replacement string may contain
+     * references to captured subsequences as in the {@link #appendReplacement
+     * appendReplacement} method.
+     *
+     * <p> Note that backslashes ({@code \}) and dollar signs ({@code $}) in
+     * a replacement string may cause the results to be different than if it
+     * were being treated as a literal replacement string. Dollar signs may be
+     * treated as references to captured subsequences as described above, and
+     * backslashes are used to escape literal characters in the replacement
+     * string.
+     *
+     * <p> Given the regular expression {@code dog}, the input
+     * {@code "zzzdogzzzdogzzz"}, and the function
+     * {@code mr -> mr.group().toUpperCase()}, an invocation of this method on
+     * a matcher for that expression would yield the string
+     * {@code "zzzDOGzzzDOGzzz"}.
+     *
+     * <p> Invoking this method changes this matcher's state.  If the matcher
+     * is to be used in further matching operations then it should first be
+     * reset.  </p>
+     *
+     * <p> The replacer function should not modify this matcher's state during
+     * replacement.  This method will, on a best-effort basis, throw a
+     * {@link java.util.ConcurrentModificationException} if such modification is
+     * detected.
+     *
+     * <p> The state of each match result passed to the replacer function is
+     * guaranteed to be constant only for the duration of the replacer function
+     * call and only if the replacer function does not modify this matcher's
+     * state.
+     *
+     * @implNote
+     * This implementation applies the replacer function to this matcher, which
+     * is an instance of {@code MatchResult}.
+     *
+     * @param  replacer
+     *         The function to be applied to the match result of this matcher
+     *         that returns a replacement string.
+     * @return  The string constructed by replacing each matching subsequence
+     *          with the result of applying the replacer function to that
+     *          matched subsequence, substituting captured subsequences as
+     *          needed.
+     * @throws NullPointerException if the replacer function is null
+     * @throws ConcurrentModificationException if it is detected, on a
+     *         best-effort basis, that the replacer function modified this
+     *         matcher's state
+     * @since 9
+     */
+    public String replaceAll(Function<MatchResult, String> replacer) {
+        Objects.requireNonNull(replacer);
+        reset();
+        boolean result = find();
+        if (result) {
+            StringBuilder sb = new StringBuilder();
+            do {
+                int ec = modCount;
+                String replacement =  replacer.apply(this);
+                if (ec != modCount)
+                    throw new ConcurrentModificationException();
+                appendReplacement(sb, replacement);
+                result = find();
+            } while (result);
+            appendTail(sb);
+            return sb.toString();
+        }
+        return text.toString();
+    }
+    /**
+     * Returns a stream of match results for each subsequence of the input
+     * sequence that matches the pattern.  The match results occur in the
+     * same order as the matching subsequences in the input sequence.
+     *
+     * <p> Each match result is produced as if by {@link #toMatchResult()}.
+     *
+     * <p> This method does not reset this matcher.  Matching starts on
+     * initiation of the terminal stream operation either at the beginning of
+     * this matcher's region, or, if the matcher has not since been reset, at
+     * the first character not matched by a previous match.
+     *
+     * <p> If the matcher is to be used for further matching operations after
+     * the terminal stream operation completes then it should be first reset.
+     *
+     * <p> This matcher's state should not be modified during execution of the
+     * returned stream's pipeline.  The returned stream's source
+     * {@code Spliterator} is <em>fail-fast</em> and will, on a best-effort
+     * basis, throw a {@link java.util.ConcurrentModificationException} if such
+     * modification is detected.
+     *
+     * @return a sequential stream of match results.
+     * @since 9
+     */
+    public Stream<MatchResult> results() {
+        class MatchResultIterator implements Iterator<MatchResult> {
+            // -ve for call to find, 0 for not found, 1 for found
+            int state = -1;
+            // State for concurrent modification checking
+            // -1 for uninitialized
+            int expectedCount = -1;
+            // The input sequence as a string, set once only after first find
+            // Avoids repeated conversion from CharSequence for each match
+            String textAsString;
+            @Override
+            public MatchResult next() {
+                if (expectedCount >= 0 && expectedCount != modCount)
+                    throw new ConcurrentModificationException();
+                if (!hasNext())
+                    throw new NoSuchElementException();
+                state = -1;
+                return toMatchResult(textAsString);
+            }
+            @Override
+            public boolean hasNext() {
+                if (state >= 0)
+                    return state == 1;
+                // Defer throwing ConcurrentModificationException to when next
+                // or forEachRemaining is called.  The is consistent with other
+                // fail-fast implementations.
+                if (expectedCount >= 0 && expectedCount != modCount)
+                    return true;
+                boolean found = find();
+                // Capture the input sequence as a string on first find
+                if (found && state < 0)
+                    textAsString = text.toString();
+                state = found ? 1 : 0;
+                expectedCount = modCount;
+                return found;
+            }
+            @Override
+            public void forEachRemaining(Consumer<? super MatchResult> action) {
+                if (expectedCount >= 0 && expectedCount != modCount)
+                    throw new ConcurrentModificationException();
+                int s = state;
+                if (s == 0)
+                    return;
+                // Set state to report no more elements on further operations
+                state = 0;
+                expectedCount = -1;
+                // Perform a first find if required
+                if (s < 0 && !find())
+                    return;
+                // Capture the input sequence as a string on first find
+                textAsString = text.toString();
+                do {
+                    int ec = modCount;
+                    action.accept(toMatchResult(textAsString));
+                    if (ec != modCount)
+                        throw new ConcurrentModificationException();
+                } while (find());
+            }
+        }
+        return StreamSupport.stream(Spliterators.spliteratorUnknownSize(
+                new MatchResultIterator(), Spliterator.ORDERED | Spliterator.NONNULL), false);
+    }
+    /**
      * Replaces the first subsequence of the input sequence that matches the
      * pattern with the given replacement string.
      *
@@ -919,17 +1295,17 @@
      * string may contain references to captured subsequences as in the {@link
      * #appendReplacement appendReplacement} method.
      *
-     * <p>Note that backslashes (<tt>\</tt>) and dollar signs (<tt>$</tt>) in
+     * <p>Note that backslashes ({@code \}) and dollar signs ({@code $}) in
      * the replacement string may cause the results to be different than if it
      * were being treated as a literal replacement string. Dollar signs may be
      * treated as references to captured subsequences as described above, and
      * backslashes are used to escape literal characters in the replacement
      * string.
      *
-     * <p> Given the regular expression <tt>dog</tt>, the input
-     * <tt>"zzzdogzzzdogzzz"</tt>, and the replacement string
-     * <tt>"cat"</tt>, an invocation of this method on a matcher for that
-     * expression would yield the string <tt>"zzzcatzzzdogzzz"</tt>.  </p>
+     * <p> Given the regular expression {@code dog}, the input
+     * {@code "zzzdogzzzdogzzz"}, and the replacement string
+     * {@code "cat"}, an invocation of this method on a matcher for that
+     * expression would yield the string {@code "zzzcatzzzdogzzz"}.  </p>
      *
      * <p> Invoking this method changes this matcher's state.  If the matcher
      * is to be used in further matching operations then it should first be
@@ -947,7 +1323,79 @@
         reset();
         if (!find())
             return text.toString();
-        StringBuffer sb = new StringBuffer();
+        StringBuilder sb = new StringBuilder();
+        appendReplacement(sb, replacement);
+        appendTail(sb);
+        return sb.toString();
+    }
+    /**
+     * Replaces the first subsequence of the input sequence that matches the
+     * pattern with the result of applying the given replacer function to the
+     * match result of this matcher corresponding to that subsequence.
+     * Exceptions thrown by the replace function are relayed to the caller.
+     *
+     * <p> This method first resets this matcher.  It then scans the input
+     * sequence looking for a match of the pattern.  Characters that are not
+     * part of the match are appended directly to the result string; the match
+     * is replaced in the result by the applying the replacer function that
+     * returns a replacement string.  The replacement string may contain
+     * references to captured subsequences as in the {@link #appendReplacement
+     * appendReplacement} method.
+     *
+     * <p>Note that backslashes ({@code \}) and dollar signs ({@code $}) in
+     * the replacement string may cause the results to be different than if it
+     * were being treated as a literal replacement string. Dollar signs may be
+     * treated as references to captured subsequences as described above, and
+     * backslashes are used to escape literal characters in the replacement
+     * string.
+     *
+     * <p> Given the regular expression {@code dog}, the input
+     * {@code "zzzdogzzzdogzzz"}, and the function
+     * {@code mr -> mr.group().toUpperCase()}, an invocation of this method on
+     * a matcher for that expression would yield the string
+     * {@code "zzzDOGzzzdogzzz"}.
+     *
+     * <p> Invoking this method changes this matcher's state.  If the matcher
+     * is to be used in further matching operations then it should first be
+     * reset.
+     *
+     * <p> The replacer function should not modify this matcher's state during
+     * replacement.  This method will, on a best-effort basis, throw a
+     * {@link java.util.ConcurrentModificationException} if such modification is
+     * detected.
+     *
+     * <p> The state of the match result passed to the replacer function is
+     * guaranteed to be constant only for the duration of the replacer function
+     * call and only if the replacer function does not modify this matcher's
+     * state.
+     *
+     * @implNote
+     * This implementation applies the replacer function to this matcher, which
+     * is an instance of {@code MatchResult}.
+     *
+     * @param  replacer
+     *         The function to be applied to the match result of this matcher
+     *         that returns a replacement string.
+     * @return  The string constructed by replacing the first matching
+     *          subsequence with the result of applying the replacer function to
+     *          the matched subsequence, substituting captured subsequences as
+     *          needed.
+     * @throws NullPointerException if the replacer function is null
+     * @throws ConcurrentModificationException if it is detected, on a
+     *         best-effort basis, that the replacer function modified this
+     *         matcher's state
+     * @since 9
+     */
+    public String replaceFirst(Function<MatchResult, String> replacer) {
+        Objects.requireNonNull(replacer);
+        reset();
+        if (!find())
+            return text.toString();
+        StringBuilder sb = new StringBuilder();
+        int ec = modCount;
+        String replacement = replacer.apply(this);
+        if (ec != modCount)
+            throw new ConcurrentModificationException();
         appendReplacement(sb, replacement);
         appendTail(sb);
         return sb.toString();
@@ -956,8 +1404,8 @@
      * Sets the limits of this matcher's region. The region is the part of the
      * input sequence that will be searched to find a match. Invoking this
      * method resets the matcher, and then sets the region to start at the
-     * index specified by the <code>start</code> parameter and end at the
-     * index specified by the <code>end</code> parameter.
+     * index specified by the {@code start} parameter and end at the
+     * index specified by the {@code end} parameter.
      *
      * <p>Depending on the transparency and anchoring being used (see
      * {@link #useTransparentBounds useTransparentBounds} and
@@ -1016,8 +1464,8 @@
     /**
      * Queries the transparency of region bounds for this matcher.
      *
-     * <p> This method returns <tt>true</tt> if this matcher uses
-     * <i>transparent</i> bounds, <tt>false</tt> if it uses <i>opaque</i>
+     * <p> This method returns {@code true} if this matcher uses
+     * <i>transparent</i> bounds, {@code false} if it uses <i>opaque</i>
      * bounds.
      *
      * <p> See {@link #useTransparentBounds useTransparentBounds} for a
@@ -1025,8 +1473,8 @@
      *
      * <p> By default, a matcher uses opaque region boundaries.
      *
-     * @return <tt>true</tt> iff this matcher is using transparent bounds,
-     *         <tt>false</tt> otherwise.
+     * @return {@code true} iff this matcher is using transparent bounds,
+     *         {@code false} otherwise.
      * @see java.util.regex.Matcher#useTransparentBounds(boolean)
      * @since 1.5
      */
@@ -1036,9 +1484,9 @@
     /**
      * Sets the transparency of region bounds for this matcher.
      *
-     * <p> Invoking this method with an argument of <tt>true</tt> will set this
+     * <p> Invoking this method with an argument of {@code true} will set this
      * matcher to use <i>transparent</i> bounds. If the boolean
-     * argument is <tt>false</tt>, then <i>opaque</i> bounds will be used.
+     * argument is {@code false}, then <i>opaque</i> bounds will be used.
      *
      * <p> Using transparent bounds, the boundaries of this
      * matcher's region are transparent to lookahead, lookbehind,
@@ -1066,16 +1514,16 @@
     /**
      * Queries the anchoring of region bounds for this matcher.
      *
-     * <p> This method returns <tt>true</tt> if this matcher uses
-     * <i>anchoring</i> bounds, <tt>false</tt> otherwise.
+     * <p> This method returns {@code true} if this matcher uses
+     * <i>anchoring</i> bounds, {@code false} otherwise.
      *
      * <p> See {@link #useAnchoringBounds useAnchoringBounds} for a
      * description of anchoring bounds.
      *
      * <p> By default, a matcher uses anchoring region boundaries.
      *
-     * @return <tt>true</tt> iff this matcher is using anchoring bounds,
-     *         <tt>false</tt> otherwise.
+     * @return {@code true} iff this matcher is using anchoring bounds,
+     *         {@code false} otherwise.
      * @see java.util.regex.Matcher#useAnchoringBounds(boolean)
      * @since 1.5
      */
@@ -1085,9 +1533,9 @@
     /**
      * Sets the anchoring of region bounds for this matcher.
      *
-     * <p> Invoking this method with an argument of <tt>true</tt> will set this
+     * <p> Invoking this method with an argument of {@code true} will set this
      * matcher to use <i>anchoring</i> bounds. If the boolean
-     * argument is <tt>false</tt>, then <i>non-anchoring</i> bounds will be
+     * argument is {@code false}, then <i>non-anchoring</i> bounds will be
      * used.
      *
      * <p> Using anchoring bounds, the boundaries of this
@@ -1109,7 +1557,7 @@
     }
     /**
      * <p>Returns the string representation of this matcher. The
-     * string representation of a <code>Matcher</code> contains information
+     * string representation of a {@code Matcher} contains information
      * that may be useful for debugging. The exact format is unspecified.
      *
      * @return  The string representation of this matcher
@@ -1117,15 +1565,15 @@
      */
     public String toString() {
         StringBuilder sb = new StringBuilder();
-        sb.append("java.util.regex.Matcher");
-        sb.append("[pattern=" + pattern());
-        sb.append(" region=");
-        sb.append(regionStart() + "," + regionEnd());
-        sb.append(" lastmatch=");
+        sb.append("java.util.regex.Matcher")
+                .append("[pattern=").append(pattern())
+                .append(" region=")
+                .append(regionStart()).append(',').append(regionEnd())
+                .append(" lastmatch=");
         if ((first >= 0) && (group() != null)) {
             sb.append(group());
         }
-        sb.append("]");
+        sb.append(']');
         return sb.toString();
     }
     /**
@@ -1180,11 +1628,16 @@
         this.oldLast = oldLast < 0 ? from : oldLast;
         for (int i = 0; i < groups.length; i++)
             groups[i] = -1;
+        for (int i = 0; i < localsPos.length; i++) {
+            if (localsPos[i] != null)
+                localsPos[i].clear();
+        }
         acceptMode = NOANCHOR;
         boolean result = parentPattern.root.match(this, from, text);
         if (!result)
             this.first = -1;
         this.oldLast = this.last;
+        this.modCount++;
         return result;
     }
     /**
@@ -1201,11 +1654,16 @@
         this.oldLast = oldLast < 0 ? from : oldLast;
         for (int i = 0; i < groups.length; i++)
             groups[i] = -1;
+        for (int i = 0; i < localsPos.length; i++) {
+            if (localsPos[i] != null)
+                localsPos[i].clear();
+        }
         acceptMode = anchor;
         boolean result = parentPattern.matchRoot.match(this, from, text);
         if (!result)
             this.first = -1;
         this.oldLast = this.last;
+        this.modCount++;
         return result;
     }
     /**
